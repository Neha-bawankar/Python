# create multithreading in pyhton
# step-1 import thread class from threading module
import os
import time
from threading import Thread, current_thread, main_thread, active_count, get_native_id


#step -2 create function containing code to be executed parallaly
def display(n,msg):       #n, msg
    for i in range(n):  #n
        print(msg)  #msg

#step 3 - create an object of thread class

#t1 = Thread(target= display, args=(4,"Hii" ))
t1 = Thread(target= display, kwargs ={"n": 4, "msg":"hello world"})
#t1 = Thread(target=display)

#step4 - start created thread using start() method
t1.start()


for i in range(4):
    print("welcome")



#Threads from method
class Example:
    def display(self):
        for i in range(5):
            print("hello world")
e1 = Example()
t1 = Thread(target=e1.display)
t1.start()

'''
#creating threads by extending Thread class - using concept method overriding
from time import sleep

videos =['oops syllabus', 'constructor','destructor', 'file handling']
'''
class Myclass(Thread):
    def run(self):
        for vid in videos:
            print(f" {vid} starting uploading...")
            sleep(3)
            print(f" {vid} uploaded..")

t1=Myclass()
t1.start()


for i in range(4):     # in this there is two thread main thread checking copyright and t1 thread uploading videos
    sleep(0.5)
    print("checking copyrights")

'''

#can we use constructor with thread
'''
class Myclass(Thread):
    def __init__(self):
        print("constructor called")
       # Thread.__init__(self)
    def run(self):
        for vid in videos:
            print(f" {vid} starting uploading...")
            sleep(3)
            print(f" {vid} uploaded..")

t1=Myclass()
t1.start()

for i in range(4):     # in this there is two thread main thread checking copyright and t1 thread uploading videos
    sleep(0.5)
    print("checking copyrights")


#biggest advantage of using this way of creating threads?
#ans - you can access data generated by threads


#Thread Names and Threading identity numbers
def display():
    for i in range(4):
        print("Hello world")

def show():
    for i in range(3):
        print("welcome")

t1 = Thread(target=display)
t2 = Thread(target=show)

print(t1.name)
print(t2.name)
t1.name = 'Shantanu'
current_thread().name= t1.name
print(current_thread().name)



#Thread Identifiers -
def display():
    for i in range(4):
        print("Hello world")

def show():
    for i in range(3):
        print("welcome")

t1 = Thread(target=display)
t2 = Thread(target=show)
t1.start()
t2.start()
print(t1.ident)
print(t1.native_id)
print(os.getpid())


#built-in functions for mutithreding
#1 - is_alive() - check thread is running or not
#2 - mainthread() - return main thread details
#3 - active_count()- number of running threads
#4- enumerate() - List of all running threads
#5 -get_native_id() - know the native id thread



def display():
    print("main thread details: ", main_thread())
    print("native  id: ", get_native_id())
    for i in range(4):
        print("Hello world")

def show():
    for i in range(3):
        print("welcome")

t3 = Thread(target=display)
t2 = Thread(target=show)
print(t3.is_alive())
t3.start()
print("number of thread: ", active_count())
#print("number of thread: ", enumerate())
print(t3.is_alive())


#join method - if a thread wants to wait for some ohter thread then we should go for join() meyhod
#we called join method with thread object

def display():
    for i in range(4):
        print("Welcome")

def show():
    for i in range(3):
        print("lets start the programming")

t1 = Thread(target=display)
t2 = Thread(target=show)
t1.start()
t1.join() # stop t2 execution whenever t1 execution not completed
t2.start()
t2.join()
for i in range(5):
    print("hello world")

#why to used multithreading
def square(num):
    print("Finding square:..")
    time.sleep(1)
    print(f"square of {num} is: ", num **2)

def cube(num):
    print("Finding cube:..")
    time.sleep(1)
    print(f"cube of {num} is: ", num ** 3)

begin= time.time()   #epoch - 1jan 2002 - 1000
t1 = Thread(target=square, args=(3,))
t2 = Thread(target=cube, args=(3,))
t1.start()
t2.start()
t1.join()
t2.join()
print("total time taken: " , time.time() - begin)


#race condition - 
Ex-1 Bus Ticketing system

from threading import  *


import threading

class Bus:
    def __init__(self):
        self.seats = 1

    def book_seat(self):
        if self.seats > 0:
            print("Seat available, booking...")
            self.seats -= 1
            print("Seat booked")
        else:
            print("No seats left")

bus = Bus()

t1 = Thread(target=bus.book_seat)
t2 = Thread(target=bus.book_seat)

t1.start()
t2.start()

t1.join()
t2.join()

print("Seats left:", bus.seats)

#Thread sychronization Techiniue  to fix race condition -
# a common approach is to protect the critical section of code
#1 Technique - Using Lock


#step1 -create an object of lock class
#step2-  Acquire lock using acquire()

#step3 - Release  lock using release method.

mylock = Lock()

def task(mylock, msg):
    mylock.acquire()
    
    for i in range(5):
        print(msg)
    sleep(3)
    mylock.release()


t1 = Thread(target=task, args=(mylock, 'Hello world') )
t2 = Thread(target=task, args=(mylock, 'Welcome'))
t1.start()
t2.start()



#solve race condition using lock
class Bus:
    def __init__(self):
        self.seats = 1
        self.lock = Lock()

    def book_seat(self):
        self.lock.acquire()
        if self.seats > 0:
            print("Seat available, booking...")
            self.seats -= 1
            print("Seat booked")
        else:
            print("sorry! No seats left")
        self.lock.release()

bus = Bus()

t1 = Thread(target=bus.book_seat)
t2 = Thread(target=bus.book_seat)

t1.start()
t2.start()

t1.join()
t2.join()

print("Seats left:", bus.seats)

#solve race condition using RLock

class Bus:
    def __init__(self):
        self.seats = 1
        self.rlock = RLock()

    def book_seat(self):
        self.rlock.acquire()
        self.rlock.acquire()
        if self.seats > 0:
            print("Seat available, booking...")
            self.seats -= 1
            print("Seat booked")
        else:
            print("No seats left")

        self.rlock.release()
        self.rlock.release()

bus = Bus()

t1 = Thread(target=bus.book_seat)
t2 = Thread(target=bus.book_seat)

t1.start()
t2.start()

t1.join()
t2.join()

print("Seats left:", bus.seats)

#in lock and rlock at a time only one thread is allowed to execute
#but sometimes our requirement is to execute a particular number of thread at a time

#solve using semaphore-  used to limit the access ot the shared  resources with limited capacity

class ParkingLot:
    def __init__(self):
        self.spots= Semaphore(3)

    def park_car(self, car_name):
        print(f" {car_name} waiting to park")
        self.spots.acquire()

        print(f" {car_name} parked")
        time.sleep(5)

        print(f" {car_name} leaving")
        self.spots.release()

parking = ParkingLot()

cars =["car 1", "car 2", "car 3", "car 4", "car 5", "car 6"]



thread =[]
for car in cars:
    t1 = Thread(target=parking.park_car, args=(car,))
   
    t1.start()



#Exception in mutithreading


def custome_hook(args):
    print("Exception ocurred in thread")
    print(args[0])
    print(args[1])
    print(args[2])
    print(args[3])
def display():
    for i in range(4):
        sleep(0.5)
        print("hello:" +10)

def show():
    for i in range(4):
        print("bye")
        sleep(1.5)

threading.excepthook =  custome_hook
t1 = Thread(target=display)
t2 = Thread(target=show)
t1.start()
t2.start()
t1.join()
t2.join()

for i in range(4):
    print("welcome")



#Thread communication - in concurrent programming sometime we need to co-ordinate threads.

